#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : enable
#extension GL_EXT_buffer_reference2 : enable
#extension GL_NV_ray_tracing : enable

#include "payload.shinc"
#include "rand.shinc"
#include "image.shinc"
#include "raygen_params.shinc"

layout(binding = 0, set = 0) uniform accelerationStructureNV topLevelAS;

layout(std430, binding = 2) buffer BufStates
{
    RNGState states[];
};

layout(location = 0) rayPayloadNV Payload payload;
layout(location = 1) rayPayloadNV bool isShadowed;


float schlick(float cosine, float ref_idx)
{
    float r0 = (1.0 - ref_idx) / (1.0 + ref_idx);
    r0 = r0 * r0;
    return r0 + (1.0 - r0)*pow(1.0 - cosine, 5.0);
}


void main() 
{
    uint ray_id = gl_LaunchIDNV.x + gl_LaunchIDNV.y*target.width;

	float fx = float(gl_LaunchIDNV.x)+ rand01(states[ray_id]);
	float fy = float(gl_LaunchIDNV.y)+ rand01(states[ray_id]);

	vec3 pos_pix = upper_left.xyz + fx * ux.xyz + fy * uy.xyz;
	
	uint cullMask = 0xff;
    float tmin = 0.0001;
    float tmax = 10000.0;

    vec3 ray_origin = origin.xyz;

    if (lens_radius > 0.0f)
    {
        vec3 u = normalize(ux.xyz);
        vec3 v = normalize(uy.xyz);
        vec2 rd = lens_radius * rand_in_unit_disk(states[ray_id]);
        ray_origin += u * rd.x + v * rd.y;
    }

    vec3 direction =  normalize(pos_pix - ray_origin);


    vec3 color = vec3(0.0, 0.0, 0.0);
    vec3 f_att = vec3(1.0, 1.0, 1.0);
    int depth = 0;
    while (f_att.x > 0.0001 || f_att.y > 0.0001 || f_att.z > 0.0001)
    {
        if (depth >= 10) break;

        uint rayFlags = gl_RayFlagsOpaqueNV;
        traceNV(topLevelAS, rayFlags, cullMask, 0, 0, 0, ray_origin, tmin, direction, tmax, 0);

        float t = payload.color_dis.w;
        if (t>0.0)
        {
            ray_origin += direction*t;

            /*vec3 lightVector = normalize(vec3(5, 4, 3));
            float dot_product = dot(lightVector, payload.normal.xyz);

            rayFlags =  gl_RayFlagsTerminateOnFirstHitNV|gl_RayFlagsOpaqueNV|gl_RayFlagsSkipClosestHitShaderNV;
            isShadowed = true;
            if (dot_product>0.0)
                traceNV(topLevelAS, rayFlags, cullMask, 0, 0, 1, ray_origin, tmin, lightVector, tmax, 1);
            if (!isShadowed)
                color += vec3(0.7,0.7,0.7)*dot_product*f_att;*/

            vec3 fuzz_dir = payload.normal.xyz;

            if (payload.material == 0 || payload.material == 1)
            {
                f_att *= payload.color_dis.xyz;
            }

            if (payload.material == 0)
            {
                direction = normalize(rand_in_unit_sphere(states[ray_id]) + payload.normal.xyz);
            }
            else if (payload.material == 1)
            {
                direction = reflect(direction, payload.normal.xyz);
            }
            else if (payload.material == 2)
            {
                float reflect_prob = 1.0f;
                bool enter = payload.ref_idx < 1.0;
                float ref_idx = payload.ref_idx;
                vec3 normal = -payload.normal.xyz;

                if (dot(direction, payload.normal.xyz)<0)
                {
                    enter = !enter;
                    ref_idx = 1.0 / ref_idx;
                    normal = payload.normal.xyz;
                }

                vec3 refracted = refract(direction, normal, ref_idx);
                if (refracted.x != 0.0 || refracted.y!= 0.0 || refracted.z != 0.0)
                {
                    float cosine = -dot(direction, normal);
                    reflect_prob = schlick(cosine, ref_idx);
                }

                if (rand01(states[ray_id]) < reflect_prob)
                {
                    direction = reflect(direction, normal);
                    fuzz_dir = normal;
                }
                else
                {
                    direction = refracted;
                    fuzz_dir = - fuzz_dir;
                }

                if (!enter)
                {
                    f_att.x *= pow(payload.color_dis.x, t);
                    f_att.y *= pow(payload.color_dis.y, t);
                    f_att.z *= pow(payload.color_dis.z, t);
                }
            }

            if (payload.fuzz>0.0 && (payload.material == 1 || payload.material == 2))            
            {
                float f = payload.fuzz; if (f > 1.0f) f = 1.0f;
                direction = direction + f * rand_in_unit_sphere(states[ray_id]);
                if (dot(direction, fuzz_dir) <= 0.0f)
                {
                    f_att = vec3(0.0);
                    break;
                }
                direction = normalize(direction);
            }
        }
        else 
        {
            color += payload.color_dis.xyz * f_att;
            break;
        }
        depth++;
    }
    vec4 col_old = read_pixel(target, int(gl_LaunchIDNV.x), int(gl_LaunchIDNV.y));
	vec4 col = vec4(col_old.xyz+color, 1.0);
    write_pixel(target, int(gl_LaunchIDNV.x), int(gl_LaunchIDNV.y), col);
}



